<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Whirligig Blade Designer</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React and ReactDOM -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        body { font-family: 'Inter', sans-serif; }
        input[type="range"] { accent-color: #2563eb; }
    </style>
</head>
<body class="bg-slate-50">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useMemo, useEffect } = React;
        
        // Manual Lucide components wrapper for browser usage
        const Icon = ({ name, size = 24, className = "" }) => {
            useEffect(() => {
                lucide.createIcons();
            }, [name]);
            return <i data-lucide={name} style={{ width: size, height: size }} className={className}></i>;
        };

        const App = () => {
            const IN_TO_MM = 25.4;
            const IN_TO_PX = 40;
            const EXPORT_DPI = 150;
            const DEFAULT_PITCH = 25;
            const HUB_DIAMETER_FIXED = 3.5;

            const PRESETS = {
                leaf: { rootWidth: 1.75, tipWidth: 2.5, tipRadius: 0.65, widthPosition: 0.6, taperSharpness: 0.4, edgeCurvature: 0.5 },
                rounded: { rootWidth: 2.5, tipWidth: 1.25, tipRadius: 0.5, widthPosition: 0.5, taperSharpness: 0.5, edgeCurvature: 0.38 }
            };

            const [unit, setUnit] = useState('imperial');
            const [isSidebarOpen, setIsSidebarOpen] = useState(true);
            const [params, setParams] = useState({
                exposedLength: 10.5, tabLength: 1.0, tabWidth: 2.25,
                ...PRESETS.leaf, kerfOffset: 0.005, tipStyle: 'leaf',
                quantity: 5, hasPinHole: true, pinHoleSize: 0.125, pinHoleOffset: 0.5,
            });

            const [inputStates, setInputStates] = useState({
                exposedLength: "10.5", tabLength: "1.0", tabWidth: "2.25",
                rootWidth: "1.75", tipWidth: "2.5", pinHoleSize: "0.125", pinHoleOffset: "0.5"
            });

            const toDisplayValue = (val) => unit === 'metric' ? (val * IN_TO_MM) : val;
            const fromDisplayValue = (val) => unit === 'metric' ? val / IN_TO_MM : val;
            const unitLabel = unit === 'imperial' ? 'in' : 'mm';

            const toggleUnits = () => {
                const newUnit = unit === 'imperial' ? 'metric' : 'imperial';
                setUnit(newUnit);
                const newStates = {};
                Object.keys(params).forEach(key => {
                    if (typeof params[key] !== 'number') return;
                    const val = params[key];
                    const needsConversion = ['exposedLength', 'tabLength', 'tabWidth', 'rootWidth', 'tipWidth', 'pinHoleSize', 'pinHoleOffset'].includes(key);
                    const displayVal = needsConversion ? (newUnit === 'metric' ? (val * IN_TO_MM) : val) : val;
                    newStates[key] = needsConversion ? displayVal.toFixed(newUnit === 'metric' ? 1 : 3) : val.toString();
                });
                setInputStates(newStates);
            };

            const handleTextChange = (key, rawValue) => {
                setInputStates(prev => ({ ...prev, [key]: rawValue }));
                const numericValue = parseFloat(rawValue);
                if (!isNaN(numericValue)) {
                    setParams(prev => ({ ...prev, [key]: fromDisplayValue(Math.max(0.001, numericValue)) }));
                }
            };

            const handleSliderChange = (key, value) => {
                const numeric = parseFloat(value);
                setParams(prev => ({ ...prev, [key]: fromDisplayValue(numeric) }));
                
                // Sync specific keys that have manual text inputs
                if (key === 'tipRadius' || key === 'tipWidth') {
                    setInputStates(prev => ({ 
                        ...prev, 
                        [key]: numeric.toFixed(unit === 'metric' ? 1 : 3).replace(/\.?0+$/, '') 
                    }));
                }
            };

            const handleStyleChange = (style) => {
                const preset = PRESETS[style];
                setParams(prev => ({ ...prev, ...preset, tipStyle: style }));
                const newStates = { ...inputStates };
                Object.keys(preset).forEach(key => {
                    const val = preset[key];
                    const needsConversion = ['rootWidth', 'tipWidth'].includes(key);
                    const displayVal = needsConversion ? (unit === 'metric' ? (val * IN_TO_MM) : val) : val;
                    newStates[key] = needsConversion ? displayVal.toFixed(unit === 'metric' ? 1 : 3) : val.toString();
                });
                setInputStates(newStates);
            };

            const getWidthAt = (x, p) => {
                const hRoot = p.rootWidth / 2;
                const hMax = p.tipWidth / 2;
                const L = Math.max(0.1, p.exposedLength);
                if (x < 0) return p.tabWidth / 2;
                if (p.tipStyle === 'leaf') {
                    const bX = L * p.widthPosition;
                    const t = x <= bX ? x / Math.max(0.001, bX) : (x - bX) / Math.max(0.001, L - bX);
                    if (x <= bX) return hRoot + (hMax - hRoot) * Math.sin((t * Math.PI) / 2);
                    const curve = Math.pow(Math.max(0, 1 - t), 1 + p.taperSharpness * 3) * (1 - p.tipRadius) + Math.sqrt(Math.max(0, 1 - t * t)) * p.tipRadius;
                    return hMax * curve;
                } else {
                    const t = x / L;
                    const curvePower = p.edgeCurvature < 0.5 ? 1 + (0.5 - p.edgeCurvature) * 4 : 1 / (1 + (p.edgeCurvature - 0.5) * 4);
                    let w = hRoot + (hMax - hRoot) * Math.pow(t, curvePower);
                    if (x > L - p.tipRadius) {
                        const tr = Math.max(0.01, p.tipRadius);
                        const ratio = (x - (L - tr)) / tr;
                        w = Math.min(w, hMax * Math.sqrt(Math.max(0, 1 - Math.pow(ratio, 2))));
                    }
                    return w;
                }
            };

            const derived = useMemo(() => {
                const hubR = HUB_DIAMETER_FIXED / 2;
                let totalArea = params.tabLength * params.tabWidth;
                let weightedX = (-params.tabLength / 2) * totalArea;
                let momentOfInertia = 0;
                const steps = 60;
                const dx = params.exposedLength / steps;
                for (let i = 0; i < steps; i++) {
                    const x = (i + 0.5) * dx;
                    const width = getWidthAt(x, params) * 2;
                    const area = width * dx;
                    totalArea += area;
                    weightedX += x * area;
                    momentOfInertia += (Math.pow(hubR + x, 2)) * area;
                }
                const cgX = weightedX / Math.max(0.001, totalArea);
                const cgPercent = (cgX / Math.max(0.001, params.exposedLength)) * 100;
                const score = momentOfInertia / 100;
                return {
                    cgX, cgPercent, 
                    sensitivity: (cgPercent / 40) * (Math.sin(DEFAULT_PITCH * Math.PI / 180) / 0.42) > 1.2 ? "Low (Heavy)" : "High",
                    flywheelRating: score > 14 ? "High Coast" : score > 8 ? "Steady" : "Snappy"
                };
            }, [params]);

            const generateBladePath = (p, isClosed = true, scale = IN_TO_PX, applyKerf = false) => {
                const k = applyKerf ? p.kerfOffset * scale : 0;
                const totalX = p.exposedLength * scale + k;
                const tabStartX = -p.tabLength * scale - k;
                const hTab = (p.tabWidth / 2) * scale;
                const hRoot = (p.rootWidth / 2) * scale;
                const hTip = (p.tipWidth / 2) * scale;
                let path = `M ${tabStartX} ${-hTab - k} L ${tabStartX} ${hTab + k} L 0 ${hTab + k} L 0 ${hRoot + k} `;
                if (p.tipStyle === 'leaf') {
                    const bX = p.exposedLength * p.widthPosition * scale;
                    path += `C ${bX * 0.5} ${hRoot + k} ${bX * 0.85} ${hTip + k} ${bX} ${hTip + k} `;
                    path += `C ${bX + ((totalX - bX) * (1 - p.taperSharpness))} ${hTip + k} ${totalX} ${(hTip + k) * (1 - p.tipRadius)} ${totalX} 0 `;
                    path += `C ${totalX} ${-(hTip + k) * (1 - p.tipRadius)} ${bX + ((totalX - bX) * (1 - p.taperSharpness))} ${-(hTip + k)} ${bX} ${-(hTip + k)} `;
                    path += `C ${bX * 0.85} ${-(hTip + k)} ${bX * 0.5} ${-hRoot - k} 0 ${-hRoot - k} `;
                } else {
                    const cpX = totalX * 0.5;
                    const curveY = (hRoot + (hTip - hRoot) * 0.5) + (p.edgeCurvature - 0.5) * 100;
                    const r = Math.max(0.001, Math.min(p.tipRadius * scale, totalX * 0.3, hTip));
                    path += `Q ${cpX} ${curveY} ${totalX - r} ${hTip + k} Q ${totalX} ${hTip + k} ${totalX} 0 Q ${totalX} ${-hTip - k} ${totalX - r} ${-hTip - k} Q ${cpX} ${-curveY} 0 ${-hRoot - k} `;
                }
                return path + `L 0 ${-hRoot - k} L 0 ${-hTab - k} Z`;
            };

            const downloadSVG = () => {
                const maxW = params.exposedLength + params.tabLength;
                const maxH = Math.max(params.rootWidth, params.tabWidth, params.tipWidth);
                const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${maxW+1}in" height="${maxH+1}in" viewBox="0 0 ${maxW+1} ${maxH+1}"><path d="${generateBladePath(params, true, 1, true)}" transform="translate(${params.tabLength+0.5}, ${maxH/2+0.5})" fill="none" stroke="black" stroke-width="0.01" />${params.hasPinHole ? `<circle cx="${params.tabLength+0.5-params.pinHoleOffset}" cy="${maxH/2+0.5}" r="${params.pinHoleSize/2}" fill="none" stroke="red" stroke-width="0.01" />` : ''}</svg>`;
                const link = document.createElement('a');
                link.href = URL.createObjectURL(new Blob([svg], { type: 'image/svg+xml' }));
                link.download = 'blade_template.svg';
                link.click();
            };

            const downloadJPG = () => {
                const scale = EXPORT_DPI;
                const maxW = params.exposedLength + params.tabLength;
                const maxH = Math.max(params.rootWidth, params.tabWidth, params.tipWidth);
                const canvas = document.createElement('canvas');
                canvas.width = (maxW + 2) * scale; canvas.height = (maxH + 2) * scale;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = 'white'; ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.save(); ctx.translate((params.tabLength + 1) * scale, (maxH / 2 + 1) * scale);
                ctx.strokeStyle = 'black'; ctx.lineWidth = 3;
                ctx.stroke(new Path2D(generateBladePath(params, true, scale, false)));
                if (params.hasPinHole) { ctx.beginPath(); ctx.arc(-params.pinHoleOffset * scale, 0, (params.pinHoleSize / 2) * scale, 0, Math.PI * 2); ctx.strokeStyle = 'red'; ctx.stroke(); }
                ctx.restore();
                
                const barY = canvas.height - (0.5 * scale); const barX = 1 * scale;
                ctx.fillStyle = '#64748b'; ctx.font = `bold ${Math.round(0.12 * scale)}px sans-serif`;
                ctx.fillText(unit === 'imperial' ? "1 INCH SCALE BAR" : "50MM SCALE BAR", barX, barY - 10);
                ctx.beginPath(); ctx.moveTo(barX, barY);
                ctx.lineTo(barX + (unit === 'imperial' ? 1 : 50 / IN_TO_MM) * scale, barY);
                ctx.strokeStyle = '#64748b'; ctx.lineWidth = 3; ctx.stroke();

                const link = document.createElement('a'); link.href = canvas.toDataURL('image/jpeg', 0.95); link.download = 'blade_template.jpg'; link.click();
            };

            return (
                <div className="flex flex-col md:flex-row h-screen overflow-hidden text-slate-900 bg-slate-50">
                    <div className={`w-full md:w-80 bg-white border-r flex flex-col shadow-sm transition-all ${isSidebarOpen ? '' : 'md:w-0'}`}>
                        <div className="p-4 border-b flex justify-between items-center bg-white sticky top-0 z-10">
                            <div className="flex items-center gap-2"><Icon name="wind" className="text-blue-600" size={20}/> <h1 className="font-bold text-sm tracking-tight">Blade Designer</h1></div>
                            <button onClick={toggleUnits} className="text-[10px] font-bold uppercase bg-slate-100 px-2 py-1 rounded hover:bg-slate-200 transition-colors">{unit}</button>
                        </div>
                        <div className="flex-1 overflow-y-auto p-4 space-y-6">
                            <div className="grid grid-cols-2 gap-1 bg-slate-100 p-1 rounded-lg">
                                <button onClick={() => handleStyleChange('rounded')} className={`py-1.5 text-xs font-bold rounded ${params.tipStyle==='rounded'?'bg-white shadow text-blue-600':'text-slate-500 hover:text-slate-700'}`}>Round</button>
                                <button onClick={() => handleStyleChange('leaf')} className={`py-1.5 text-xs font-bold rounded ${params.tipStyle==='leaf'?'bg-white shadow text-blue-600':'text-slate-500 hover:text-slate-700'}`}>Leaf</button>
                            </div>
                            <div className="space-y-4">
                                <label className="text-[10px] font-bold uppercase text-slate-400 block tracking-widest">Geometry</label>
                                <div>
                                    <label className="text-xs text-slate-500 mb-1 block font-medium">Exposed Length</label>
                                    <input type="text" value={inputStates.exposedLength} onChange={e => handleTextChange('exposedLength', e.target.value)} className="w-full p-2 border rounded text-sm font-mono outline-none focus:ring-2 focus:ring-blue-500 transition-shadow"/>
                                </div>
                                {params.tipStyle === 'leaf' ? (
                                    <div className="p-3 bg-slate-50 border border-slate-100 rounded-xl space-y-3 shadow-inner">
                                        <div><label className="text-[10px] font-bold text-slate-600 uppercase">Swell Position</label><input type="range" min="0.1" max="0.9" step="0.05" value={params.widthPosition} onChange={e => setParams({...params, widthPosition: parseFloat(e.target.value)})} className="w-full h-1.5 bg-slate-200 rounded-lg appearance-none cursor-pointer"/></div>
                                        <div><label className="text-[10px] font-bold text-slate-600 uppercase">Swell Width</label><input type="range" min={toDisplayValue(0.5)} max={toDisplayValue(5)} step={toDisplayValue(0.05)} value={toDisplayValue(params.tipWidth)} onChange={e => handleSliderChange('tipWidth', e.target.value)} className="w-full h-1.5 bg-slate-200 rounded-lg appearance-none cursor-pointer"/></div>
                                        <div><label className="text-[10px] font-bold text-slate-600 uppercase">Sharpness</label><input type="range" min="0" max="1" step="0.05" value={params.taperSharpness} onChange={e => setParams({...params, taperSharpness: parseFloat(e.target.value)})} className="w-full h-1.5 bg-slate-200 rounded-lg appearance-none cursor-pointer"/></div>
                                        <div><label className="text-[10px] font-bold text-slate-600 uppercase">Bluntness</label><input type="range" min="0" max="1" step="0.05" value={params.tipRadius} onChange={e => setParams({...params, tipRadius: parseFloat(e.target.value)})} className="w-full h-1.5 bg-slate-200 rounded-lg appearance-none cursor-pointer"/></div>
                                    </div>
                                ) : (
                                    <div className="p-3 bg-slate-50 border border-slate-100 rounded-xl space-y-3 shadow-inner">
                                        <div><label className="text-[10px] font-bold text-slate-600 uppercase">Curvature</label><input type="range" min="0.2" max="0.8" step="0.01" value={params.edgeCurvature} onChange={e => setParams({...params, edgeCurvature: parseFloat(e.target.value)})} className="w-full h-1.5 bg-slate-200 rounded-lg appearance-none cursor-pointer"/></div>
                                        <div><label className="text-[10px] font-bold text-slate-600 uppercase">Rounding Radius</label><input type="range" min="0" max={toDisplayValue(params.tipWidth/2)} step={0.05} value={toDisplayValue(params.tipRadius)} onChange={(e) => handleSliderChange('tipRadius', e.target.value)} className="w-full h-1.5 bg-slate-200 rounded-lg appearance-none cursor-pointer"/></div>
                                    </div>
                                )}
                                <div className="grid grid-cols-2 gap-3">
                                    <div><label className="text-xs text-slate-500 mb-1 block font-medium">{params.tipStyle==='leaf'?'Swell Width':'Max Width'}</label><input type="text" value={inputStates.tipWidth} onChange={e => handleTextChange('tipWidth', e.target.value)} className="w-full p-2 border rounded text-xs font-mono outline-none focus:ring-2 focus:ring-blue-500"/></div>
                                    <div><label className="text-xs text-slate-500 mb-1 block font-medium">Root Width</label><input type="text" value={inputStates.rootWidth} onChange={e => handleTextChange('rootWidth', e.target.value)} className="w-full p-2 border rounded text-xs font-mono outline-none focus:ring-2 focus:ring-blue-500"/></div>
                                </div>
                            </div>
                            <div className="pt-4 border-t space-y-2">
                                <label className="text-[10px] font-bold uppercase text-slate-400 block tracking-widest mb-2">Production</label>
                                <div className="grid grid-cols-2 gap-3 mb-4">
                                    <div><label className="text-xs text-slate-500 mb-1 block font-medium">Tab Len</label><input type="text" value={inputStates.tabLength} onChange={e => handleTextChange('tabLength', e.target.value)} className="w-full p-2 border rounded text-xs font-mono outline-none focus:ring-2 focus:ring-blue-500"/></div>
                                    <div><label className="text-xs text-slate-500 mb-1 block font-medium">Tab Wid</label><input type="text" value={inputStates.tabWidth} onChange={e => handleTextChange('tabWidth', e.target.value)} className="w-full p-2 border rounded text-xs font-mono outline-none focus:ring-2 focus:ring-blue-500"/></div>
                                </div>
                                <button onClick={downloadSVG} className="w-full bg-blue-600 text-white font-bold py-2 rounded-lg text-sm flex items-center justify-center gap-2 shadow-md hover:bg-blue-700 transition-all"><Icon name="download" size={16}/> Export SVG</button>
                                <button onClick={downloadJPG} className="w-full bg-slate-100 text-slate-700 font-bold py-2 rounded-lg text-sm flex items-center justify-center gap-2 hover:bg-slate-200 transition-all"><Icon name="image" size={16}/> Export JPG</button>
                            </div>
                        </div>
                    </div>

                    <div className="flex-1 relative flex flex-col min-h-0 bg-white">
                        <div className="flex-1 flex items-center justify-center p-8 bg-[radial-gradient(#e2e8f0_1.5px,transparent_1.5px)] [background-size:32px_32px]">
                            <svg className="w-full h-full drop-shadow-2xl" viewBox="-100 -200 800 400">
                                <g transform="translate(50, 0)">
                                    <line x1="-100" y1="0" x2="600" y2="0" stroke="#cbd5e1" strokeWidth="1" strokeDasharray="4 4" />
                                    
                                    {/* The blade path is now drawn first so elements below overlay it */}
                                    <path d={generateBladePath(params)} fill="#fde68a" stroke="#92400e" strokeWidth="2" className="transition-all duration-300" />
                                    
                                    {/* Sweet Spot Box and Label overlay the blade */}
                                    <rect x={params.exposedLength * 0.35 * IN_TO_PX} y="-120" width={params.exposedLength * 0.07 * IN_TO_PX} height="240" fill="#22c55e" fillOpacity="0.15" />
                                    <text 
                                        x={(params.exposedLength * 0.385) * IN_TO_PX} 
                                        y="-130" 
                                        textAnchor="middle" 
                                        className="fill-green-600 text-[8px] font-bold uppercase tracking-widest"
                                    >
                                        Sweet Spot
                                    </text>

                                    {params.hasPinHole && <circle cx={-params.pinHoleOffset * IN_TO_PX} cy="0" r={(params.pinHoleSize / 2) * IN_TO_PX} fill="white" stroke="#ef4444" strokeWidth="1.5" />}
                                    <g transform={`translate(${derived.cgX * IN_TO_PX}, 0)`} className="transition-all duration-300">
                                        <line x1="-15" y1="0" x2="15" y2="0" stroke="#ef4444" strokeWidth="2" />
                                        <line x1="0" y1="-15" x2="0" y2="15" stroke="#ef4444" strokeWidth="2" />
                                        <circle r="4" fill="#ef4444" fillOpacity="0.2" />
                                        <text y="30" textAnchor="middle" className="fill-red-600 text-[10px] font-bold uppercase tracking-tight">{derived.cgPercent.toFixed(1)}% Balance</text>
                                    </g>
                                    <g className="fill-blue-500 text-[11px] font-mono pointer-events-none">
                                        <text x={params.exposedLength * IN_TO_PX / 2} y="-20" textAnchor="middle">{toDisplayValue(params.exposedLength).toFixed(unit === 'metric' ? 1 : 2)}{unitLabel}</text>
                                        <path d={`M 0 -10 L ${params.exposedLength * IN_TO_PX} -10`} stroke="#3b82f6" strokeWidth="1" strokeDasharray="2 2" />
                                    </g>
                                </g>
                            </svg>
                        </div>
                        <div className="p-4 bg-slate-900 flex justify-between items-center text-white text-[10px] font-bold uppercase tracking-widest shadow-2xl z-20">
                            <div className="flex gap-6">
                                <span className="flex items-center gap-1.5"><Icon name="gauge" size={12} className="text-blue-400"/> SENSITIVITY: {derived.sensitivity}</span>
                                <span className="flex items-center gap-1.5"><Icon name="zap" size={12} className="text-amber-400"/> MOMENTUM: {derived.flywheelRating}</span>
                            </div>
                            <span className={`px-2 py-0.5 rounded ${derived.cgPercent >= 35 && derived.cgPercent <= 42 ? 'bg-green-600' : 'bg-amber-600'}`}>
                                {derived.cgPercent >= 35 && derived.cgPercent <= 42 ? 'IDEAL RANGE' : 'OFFSET'}
                            </span>
                        </div>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
